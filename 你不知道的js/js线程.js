
/*
    大部分浏览器都具有以下五个线程：
        js引擎线程(解释执行js代码，用户输入，网络请求)
        GUI主线程，渲染线程(绘制用户界面，他与js引擎线程是互斥的，一个被占用另一个将无法执行，此消彼长，
                因此，当js线程被大量占用时，GUI线程就无法正常进行，会造成页面卡顿);
        http网络请求线程(处理get post 请求，当请求到数据时就会将回调函数推入任务队列中，等待执行栈执行完，推入栈中执行);
        定时器触发线程(setTimeout, setInterval 等待时间到达后 将回调函数推入任务队列中)
        浏览器事件处理线程(事件被触发后会将回调函数加入事件队列中);

    js线程执行机制：
        首先它是单线程（同一时间只能做一件事，但可以通过异步去做多线程的事）
        是通过事件来驱动的；

    但如何如处理大量数据渲染哪：
        可以通过vue的ssr服务器渲染 在后端进行操作 拿到数据后再给前端
        通过这种配合实现数据交互
    js引擎具体执行机制：
        可以把每个执行的函数或执行的代码当做一个任务；在执行js代码时，会将非异步操作
        （异步操作：事件的触发，定时器，网络请求等）加入到一个主线程中，把每一步执行依次推入执行栈中
        对于将要执行的异步操作，先创建一个event table 在event table 中注册回调函数
        将回调函数推入任务队列（先入先出）中，等到应该执行回调函数时（比如定时器时间到后）就会看一下主线
        程的执行栈（先入后出）中有没有执行完 即看他为不为空 如果为空 就会将任务队列中应该执行的函数依次出队 放到
        执行栈中 然后再一次执行 当执行栈没有执行完时 任务队列需要等待执行栈执行完后才可以执行 
        这种情况就会造成定时器定时不准的现象  这个过程就叫做事件轮询(event loop);

        主线程是单线程的 必须一步一步读取 执行完就会等待任务队列中有没有能够实行的任务

        同步任务依次分先后加入到执行栈中 分层进入 先进后出 越内层越先执行依次往外执行
        同步任务执行时会先进行预编译 没编译玩一次就会创建一帧 然后把这一帧放入栈中 都压入完后就开始执行
        每执行完一次就会弹出栈 直到栈为空 再看任务队列
    


*/